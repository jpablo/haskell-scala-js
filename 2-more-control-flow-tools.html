
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>More control flow tools Â· GitBook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.2">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="3-data-structures.html" />
    
    
    <link rel="prev" href="1-informal-introduction.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    About this document
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="0-introduction.html">
            
                <a href="0-introduction.html">
            
                    
                    Installation
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="1-informal-introduction.html">
            
                <a href="1-informal-introduction.html">
            
                    
                    Informal Introduction to Scala
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4" data-path="2-more-control-flow-tools.html">
            
                <a href="2-more-control-flow-tools.html">
            
                    
                    More control flow tools
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="3-data-structures.html">
            
                <a href="3-data-structures.html">
            
                    
                    Data Structures
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="4-modules.html">
            
                <a href="4-modules.html">
            
                    
                    Modules
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >More control flow tools</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="more-control-flow-tools">More Control Flow Tools</h1>
<p>Most of the usual Python control flow constructs translate into Scala but there are a few differences that we&apos;ll be careful to indicate.</p>
<h2 id="if-expressions"><code>if</code> Expressions</h2>
<p>In Scala (unlike Python) an <code>if</code> is an <strong>expression</strong>, which means that it has a return value.</p>
<p>Consider the following Python code</p>
<pre><code class="lang-python"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint
x = randint(<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)
message = <span class="hljs-string">&apos;&apos;</span>
<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:
    message = <span class="hljs-string">&quot;Found a negative number&quot;</span>
<span class="hljs-keyword">elif</span> x == <span class="hljs-number">0</span>:
    message = <span class="hljs-string">&quot;Found zero&quot;</span>
<span class="hljs-keyword">elif</span> x &gt; <span class="hljs-number">1</span>:
    message = <span class="hljs-string">&quot;Found a positive number&quot;</span>

print(message)
</code></pre>
<p>becomes</p>
<pre><code class="lang-scala"><span class="hljs-keyword">import</span> util.<span class="hljs-type">Random</span>.nextInt
<span class="hljs-keyword">val</span> x = nextInt(<span class="hljs-number">3</span>) - <span class="hljs-number">1</span>
<span class="hljs-keyword">val</span> message =
  <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-string">&quot;Found a negative number&quot;</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>)  <span class="hljs-string">&quot;Found zero&quot;</span>
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) <span class="hljs-string">&quot;Found a positive number&quot;</span>

println(message)
</code></pre>
<p>Python&apos;s <code>if</code> doesn&apos;t return anything, so we cannot say </p>
<pre><code class="lang-python">message = <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>: ...
</code></pre>
<p>thereby forcing us to create one extra mutable variable (<code>message</code>).</p>
<blockquote>
<p>Python actually has a second <code>if</code> for that behaves in a similar (albeit limited) way:</p>
</blockquote>
<pre><code class="lang-python"><span class="hljs-comment"># Python</span>
x = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> x0
</code></pre>
<h2 id="for-comprehensions"><code>for</code> comprehensions</h2>
<p><code>for</code> expressions (called &quot;for comprehensions&quot;) are one of the most interesting aspects of Scala.</p>
<p>They operate in two ways. </p>
<h3 id="as-for-loops">As <code>for</code> loops</h3>
<p>The first one is similar to a <code>for</code> statement in Python:</p>
<pre><code class="lang-python">words = [<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Monkey&quot;</span>]
<span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words:
    print(w, len(w))
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut:book">val words = List(&quot;Cat&quot;, &quot;Dog&quot;, &quot;Monkey&quot;)
for (w &lt;- words)
  println(w, w.length)
</code></pre>
<blockquote>
<p>Note: <code>println</code> does not automatically transforms a list of arguments into a single space-separated string (as Python&apos;s <code>print</code> does).</p>
</blockquote>
<h4 id="nested-for-loops">Nested <code>for</code> loops</h4>
<p>A nested for loop in Python:</p>
<pre><code class="lang-python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):
    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(x, <span class="hljs-number">4</span>):
        <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> range(y, <span class="hljs-number">2</span>):
            <span class="hljs-keyword">print</span> (x, y, z)
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut:book">for {
  x &lt;- 0 until 2
  y &lt;- x until 4
  z &lt;- y until 2
} println(x, y, z)
</code></pre>
<h3 id="as-lists-comprehensions">As lists comprehensions</h3>
<p>The second form operates similarly to Python&apos;s list comprehensions:</p>
<pre><code class="lang-python">words_length = [len(w) <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> words]
print(words_length)
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut">val wordsLength = for (w &lt;- words) yield w.length
println(wordsLength)
</code></pre>
<p>As you can see the only difference is that now we are using the keyword <strong><code>yield</code></strong> to indicate that we want to build a new collection based on the first <code>words</code> List.</p>
<p>(We&apos;ll spend more time on for comprehensions later).</p>
<h2 id="ranges">Ranges</h2>
<table>
<thead>
<tr>
<th>Python</th>
<th>Scala</th>
<th>values</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>range(5)</code></td>
<td><code>(0 until 5)</code></td>
<td>$0, 1, 2, 3, 4$</td>
</tr>
<tr>
<td><code>range(1,6)</code></td>
<td><code>(1 to 5)</code></td>
<td>$1, 2, 3, 4, 5$</td>
</tr>
<tr>
<td><code>range(0, 10, 3)</code></td>
<td><code>(0 to 10 by 3)</code></td>
<td>$0, 3, 6, 9$</td>
</tr>
<tr>
<td><code>range(5,-1,-1)</code></td>
<td><code>(5 to 0 by -1)</code></td>
<td>$5, 4, 3, 2, 1, 0$</td>
</tr>
</tbody>
</table>
<p>To iterate over the indices of a sequence you could do the same trick as in Python:</p>
<pre><code class="lang-python">lst = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>]
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(lst)): print(i, lst[i])
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut">val lst = List(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)
for (i &lt;- 0 until lst.length) println(i, lst(i))
</code></pre>
<p>but there is a niftier way using the standard method <code>.indices</code></p>
<pre><code class="lang-tut">for (i &lt;- lst.indices) println(i, lst(i))
</code></pre>
<h2 id="enumerate">Enumerate</h2>
<p>Another standard function in Python is <code>enumerate</code>:</p>
<pre><code class="lang-python">seasons = [<span class="hljs-string">&apos;Spring&apos;</span>, <span class="hljs-string">&apos;Summer&apos;</span>, <span class="hljs-string">&apos;Fall&apos;</span>, <span class="hljs-string">&apos;Winter&apos;</span>]
list(enumerate(seasons))
[(<span class="hljs-number">0</span>, <span class="hljs-string">&apos;Spring&apos;</span>), (<span class="hljs-number">1</span>, <span class="hljs-string">&apos;Summer&apos;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&apos;Fall&apos;</span>), (<span class="hljs-number">3</span>, <span class="hljs-string">&apos;Winter&apos;</span>)]
</code></pre>
<p>Which has an analogue in Scala&apos;s <code>zipWithIndex</code> method:</p>
<pre><code class="lang-tut">val seasons = List(&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winder&quot;)
seasons.zipWithIndex
</code></pre>
<h2 id="break-continue-else-clause"><code>break</code>, <code>continue</code>, <code>else</code> clause</h2>
<p>This is one of the cases where Scala shows its functional side by not having any of those.</p>
<p>Let&apos;s examine <code>break</code> first.</p>
<p>Consider the following Python code:</p>
<pre><code class="lang-python"><span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>):
    <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n):
        <span class="hljs-keyword">if</span> n % x == <span class="hljs-number">0</span>:
            print(n, <span class="hljs-string">&apos;equals&apos;</span>, x, <span class="hljs-string">&apos;*&apos;</span>, n//x)
            <span class="hljs-keyword">break</span>
     <span class="hljs-keyword">else</span>:
        print(n, <span class="hljs-string">&apos;is a prime number&apos;</span>)
</code></pre>
<p>This can be translated mechanically to the following Scala code</p>
<pre><code class="lang-tut:book">for (n &lt;- 2 until 10) {
  var break = false
  var x = 2
  while (x &lt; n &amp;&amp; !break) {
    if (n % x == 0) {
      println(s&quot;$n equals $x * ${n / x}&quot;)
      break = true
    }
    x += 1
  }
  if (!break)
    println(s&quot;$n is a prime number&quot;)
}
</code></pre>
<p><code>continue</code> can be treated in a similar way:</p>
<pre><code class="lang-python"><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>):
    <span class="hljs-keyword">if</span> num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        print(<span class="hljs-string">&quot;Found an even number&quot;</span>, num)
        <span class="hljs-keyword">continue</span>
    print(<span class="hljs-string">&quot;Found a number&quot;</span>, num)
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut:book">var num = 2
while (num &lt; 10) {
  if (num % 2 == 0)
    println(s&quot;Found an even number $num&quot;)
  else
    println(s&quot;Found a number $num&quot;)
  num += 1
}
</code></pre>
<h2 id="pass-statements"><code>pass</code> statements</h2>
<table>
<thead>
<tr>
<th>Python</th>
<th>Scala</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>while True: pass</code></td>
<td><code>while (true) {}</code></td>
</tr>
<tr>
<td><code>class MyEmptyClass: pass</code></td>
<td><code>class MyEmptyClass</code></td>
</tr>
<tr>
<td><code>def initlog(*args): pass</code></td>
<td><code>def initlog(args: Any*) = {}</code></td>
</tr>
</tbody>
</table>
<p>So in most cases the empty body (<code>{}</code>) is a good substitute for <code>pass</code> and in classes not even that is required.</p>
<h2 id="defining-functions">Defining Functions</h2>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-string">&quot;&quot;&quot;Calculate a Fibonacci series up to n.&quot;&quot;&quot;</span>
    a, b = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> a &lt; n:
        print(a, end=<span class="hljs-string">&apos; &apos;</span>)
        a, b = b, a+b
    <span class="hljs-keyword">return</span> b

fib(<span class="hljs-number">2000</span>)
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut:silent">/**
  * Print a Fibonacci series up to n.
  */
def fib(n: Int): Int = { // &lt;= function signature
  var a = 0
  var b = 1
  var tmp = 0
  while (a &lt; n) {
    print(s&quot;$a &quot;)
    tmp = a + b; a = b; b = tmp
  }
  b     // &lt;= returned value!
}
</code></pre>
<pre><code class="lang-tut">fib(2000)
</code></pre>
<p>Observe how there is no need to use <code>return b</code>. The last expression to be evaluated is the one returned to the caller (in this case <code>b</code>).</p>
<p>So far we&apos;ve relied on Scala&apos;s hability to guess the type of our <code>val</code>s and <code>var</code>s so that we don&apos;t have to write them explicitly.</p>
<p>This is not possible on function definitions, where Scala requires us to always declare the type of the arguments. </p>
<p>Let&apos;s analize the function definition</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fib</span></span>(n: <span class="hljs-type">Int</span>): <span class="hljs-type">Int</span> = { ... }
<span class="hljs-comment">//         ^      ^      body</span>
<span class="hljs-comment">//         |      |</span>
<span class="hljs-comment">//         |   return type    </span>
<span class="hljs-comment">//         |</span>
<span class="hljs-comment">//   argument type</span>
</code></pre>
<p>This says: &quot;<em><code>fib</code> is a function that takes a single <code>Int</code> argument <code>n</code>, and returns another <code>Int</code></em>&quot;. </p>
<p>In general type annotations have the form:</p>
<pre><code>x: T
</code></pre><p>which is meant to be read: &quot;<code>x</code> is a variable that can only hold Ts&quot;.</p>
<p>For example:</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th>example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>s: String</code></td>
<td>s is a String</td>
<td><code>&quot;abc&quot;</code></td>
</tr>
<tr>
<td><code>vec: Array[Double]</code></td>
<td>vec is an array of Doubles</td>
<td><code>Array(0.1, 0.2)</code></td>
</tr>
<tr>
<td><code>mat: Array[Array[Double]]</code></td>
<td>mat is an array of array of Doubles</td>
<td><code>Array(Array(0.1, 0.2))</code></td>
</tr>
<tr>
<td><code>a: Any</code></td>
<td>a can be anything</td>
<td><code>1</code> or <code>&apos;c&apos;</code> or <code>List()</code>, etc.</td>
</tr>
</tbody>
</table>
<p>If a function doesn&apos;t return anything meaninful we can use the type <code>Unit</code>.</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span><span class="hljs-params">(x)</span>:</span>
    <span class="hljs-keyword">print</span> x + <span class="hljs-number">1</span>
</code></pre>
<p>becomes</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span></span>(x: <span class="hljs-type">Int</span>): <span class="hljs-type">Unit</span> = {
  println(x + <span class="hljs-number">1</span>)
}
</code></pre>
<p>In other languages <code>Unit</code> is called <code>void</code>.</p>
<p>A function signature with <code>Unit</code> should alerts us that the function&apos;s main purpose is not calculate but to interact with the world. For example it could print to the console, or write to a database, or remove a file.</p>
<h3 id="generic-functions">Generic functions</h3>
<p>Many functions need to know the type of its arguments so that it can invoke methods / call functions or them.</p>
<pre><code class="lang-tut:silent">def add1(x: Int) = x + 1
//                   ^
//                   |
//            plus operator
</code></pre>
<p>The compiler needs to know that <code>x</code> is an <code>Int</code> (<code>x: Int</code>) in order to allow the use of the plus operator.</p>
<p>But what if within the body of the function we don&apos;t actually make use of any method or property associated with the type? In such cases we can make the function <em>agnostic</em> to the type of the argument. </p>
<p>This is common for functions that wrap arguments, for example</p>
<pre><code class="lang-tut:silent">def toList[A](x: A) = List(x)
//         ^   
//         |
//  A is an unspecified type (a &quot;type argument&quot;)
//  Note the use of square brackets [] !!

// full form:
toList[Int](1) == List(1)

// short form:
toList(1) == List(1)
</code></pre>
<p>This function takes 2 arguments: (1) a type, called <code>A</code> inside the function and (2) a value of type <code>A</code>.</p>
<p>In many cases (but not all), the type argument can be inferred by something else (in this case by the value argument <code>x</code>).</p>
<p>One example when the type cannot be inferred is when we want to construct an empty list:</p>
<pre><code class="lang-tut:silent">List[Int]()
</code></pre>
<p>Clearly in this case the compiler doesn&apos;t have any extra information so we have to provide the type of the elements explicitly.</p>
<h2 id="more-on-defining-functions">More on defining functions</h2>
<h3 id="default-argument-values">Default argument values</h3>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ask_ok</span><span class="hljs-params">(prompt, retries=<span class="hljs-number">4</span>, reminder=<span class="hljs-string">&apos;Please try again!&apos;</span>)</span>:</span> ...
</code></pre>
<p>becomes</p>
<pre><code class="lang-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">askOk</span></span>(prompt: <span class="hljs-type">String</span>, retries: <span class="hljs-type">Int</span> = <span class="hljs-number">4</span>, reminder: <span class="hljs-type">String</span> = <span class="hljs-string">&quot;Please try again!&quot;</span>) = ???
</code></pre>
<p>Of interest here is the <code>???</code> expression. It can be used in place of any expression when we want the code to compile but we don&apos;t want to provide an implementation yet.</p>
<p>The code will compile but if the method is ever executed it will throw an exception.</p>
<h3 id="keyword-arguments">Keyword arguments</h3>
<p>Pretty much the same as in Python:</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parrot</span><span class="hljs-params">(voltage, state=<span class="hljs-string">&apos;a stiff&apos;</span>, action=<span class="hljs-string">&apos;voom&apos;</span>, type=<span class="hljs-string">&apos;Norwegian Blue&apos;</span>)</span>:</span>
    print(<span class="hljs-string">&quot;-- This parrot wouldn&apos;t&quot;</span>, action, end=<span class="hljs-string">&apos; &apos;</span>)
    print(<span class="hljs-string">&quot;if you put&quot;</span>, voltage, <span class="hljs-string">&quot;volts through it.&quot;</span>)
    print(<span class="hljs-string">&quot;-- Lovely plumage, the&quot;</span>, type)
    print(<span class="hljs-string">&quot;-- It&apos;s&quot;</span>, state, <span class="hljs-string">&quot;!&quot;</span>)
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut:silent">  def parrot(voltage: Any, state: String = &quot;a stiff&quot;, action: String = &quot;voom&quot;, `type`: String = &quot;Norwegian Blue&quot;) = {
    print(&quot;-- This parrot wouldn&apos;t &quot; +  action + &quot; &quot;)
    println(&quot;if you put &quot; + voltage + &quot; volts through it.&quot;)
    println(&quot;-- Lovely plumage, the &quot; + `type`)
    println(&quot;-- It&apos;s &quot; + state + &quot;!&quot;)
  }
</code></pre>
<pre><code class="lang-tut">parrot(1000)                                          // 1 positional argument
parrot(voltage=1000)                                  // 1 keyword argument
parrot(voltage=1000000, action=&quot;VOOOOOM&quot;)             // 2 keyword arguments
parrot(action=&quot;VOOOOOM&quot;, voltage=1000000)             // 2 keyword arguments
parrot(&quot;a million&quot;, &quot;bereft of life&quot;, &quot;jump&quot;)         // 3 positional arguments
parrot(&quot;a thousand&quot;, state=&quot;pushing up the daisies&quot;)  // 1 positional, 1 keyword
</code></pre>
<p>Note the type of the <code>voltage: Any</code> argument. In the Python function the argument <code>voltage</code> is used as a number in some cases and as a string in others.</p>
<p><code>Any</code> can be uses in such cases; it means that the argument can be of any possible type. Obviously since it is a very general type there&apos;s not much we can do with it, except printing it and maybe puting it inside a continer.</p>
<h3 id="arbitrary-argument-lists">Arbitrary Argument Lists</h3>
<p>When a function needs to take an arbitrary number of arguments the following syntax can be used:</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_multiple_items</span><span class="hljs-params">(separator, *args)</span>:</span>
    print(separator.join(args))
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut">def printMultipleItems(separator: String, args: Any*) =
  println(args.mkString(separator))

printMultipleItems(&quot;:&quot;, 1,2,3,4)
</code></pre>
<p>Inside the function <code>args</code> will be a sequence of values which we can manipulate with the usual methods from the standard library.</p>
<blockquote>
<p>Note: There is no analogue to the <code>**kwargs</code> form that is common in Python libraries.</p>
<p>An alternative in this case is to use an explicit argument which is an actual Map. </p>
</blockquote>
<h3 id="unpacking-argument-lists-">Unpacking Argument Lists: <code>:_*</code></h3>
<p>The opposite situation to variable arguments would be when a function receives a variable list of arguments and the caller has the arguments inside a list for example:</p>
<pre><code class="lang-python">my_args = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]
print_multiple_items(<span class="hljs-string">&quot;:&quot;</span>,*my_args)
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut">val myArgs = List(1,2,3,4)
printMultipleItems(&quot;:&quot;, myArgs:_*)
</code></pre>
<p>This method is more limited than Python&apos;s since only functions that explicitly support varargs can be used with this &quot;spread&quot; operator.</p>
<h3 id="lambda-expressions">Lambda Expressions</h3>
<p>A lambda expresion is just a name for an expression that represents a function but doesn&apos;t necessarily have a name. </p>
<pre><code class="lang-python"><span class="hljs-keyword">lambda</span> a, b: a + b
</code></pre>
<p>becomes</p>
<pre><code class="lang-scala">(a: <span class="hljs-type">Int</span>, b: <span class="hljs-type">Int</span>) =&gt; a + b
</code></pre>
<p>Now, in many cases the type annotations can be inferred by the compiler. Consider the method <code>filter</code>. The following 3 forms are equivalent</p>
<pre><code class="lang-tut">List(1,2,3,4).filter((x: Int) =&gt; x % 2 == 0)
</code></pre>
<pre><code class="lang-tut">List(1,2,3,4).filter(x =&gt; x % 2 == 0)
</code></pre>
<pre><code class="lang-tut">List(1,2,3,4).filter(_ % 2 == 0)
</code></pre>
<p>This last form replaces each argument for a for a single <code>_</code>.</p>
<p>For example, to sum all elements of a list:</p>
<pre><code class="lang-tut">List(1,2,3,4).reduce(_+_)
</code></pre>
<p>which is equivalent to the more verbose</p>
<pre><code class="lang-tut">List(1,2,3,4).reduce((x,y) =&gt; x + y)
</code></pre>
<p>Lambdas can be the return value of functions:</p>
<pre><code class="lang-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_incrementor</span><span class="hljs-params">(n)</span>:</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">lambda</span> x: x + n
</code></pre>
<p>becomes</p>
<pre><code class="lang-tut">def makeIncrementor(n: Int) =
  (x: Int) =&gt; x + n
</code></pre>
<p>now, what is the return type of the previous function? It is the same as</p>
<pre><code class="lang-scala"><span class="hljs-keyword">val</span> f: <span class="hljs-type">Int</span> =&gt; <span class="hljs-type">Int</span> = x =&gt; x + <span class="hljs-number">1</span>
<span class="hljs-comment">//  |   \_______/   \________/</span>
<span class="hljs-comment">// name:    |           |</span>
<span class="hljs-comment">//         type       value (a lambda)</span>
</code></pre>
<p>The above expression:</p>
<ul>
<li>Declares a value with name <code>f</code></li>
<li>and type <code>Int =&gt; Int</code></li>
<li>and value <code>(x: Int) =&gt; x + 1</code> (which is a lambda)</li>
</ul>
<p>So lambdas of one argument have type <code>A =&gt; B</code>.</p>
<p>Of two arguments: <code>(A, B) =&gt; C</code>.</p>
<p>Of three arguments: <code>(A, B, C) =&gt; D</code></p>
<p>and so on.</p>
<p>Lambdas have much more prominence in Scala than in Python due to the more functional bias of Scala. This can be seen in the collections library and in the special terse syntax.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="1-informal-introduction.html" class="navigation navigation-prev " aria-label="Previous page: Informal Introduction to Scala">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="3-data-structures.html" class="navigation navigation-next " aria-label="Next page: Data Structures">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"More control flow tools","level":"1.4","depth":1,"next":{"title":"Data Structures","level":"1.5","depth":1,"path":"3-data-structures.md","ref":"3-data-structures.md","articles":[]},"previous":{"title":"Informal Introduction to Scala","level":"1.3","depth":1,"path":"1-informal-introduction.md","ref":"1-informal-introduction.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"2-more-control-flow-tools.md","mtime":"2017-07-06T02:04:09.000Z","type":"markdown"},"gitbook":{"version":"3.2.2","time":"2017-07-06T23:50:20.298Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

